#!/usr/bin/env python

import apility
import json
import sys
from gaffer import Gaffer
import sets
import os
import time
import ipaddress

g = Gaffer("https://analytics.trustnetworks.com/gaffer-threat")
g.use_cert()

uuid = open("apility-uuid").read().lstrip().rstrip()

query = {
    "class": "uk.gov.gchq.gaffer.operation.OperationChain",
    "operations": [
        {
            "class": "uk.gov.gchq.gaffer.operation.impl.get.GetAllElements",
            "view": {
                "entities": {
                    "ip": {
                        "excludeProperties" : [ "count", "time" ],
                        "preAggregationFilterFunctions" : [
                            {
                                "selection" : [ "probe" ],
                                "predicate" : {
                                    "class" : "uk.gov.gchq.koryphe.impl.predicate.Not",
                                    "predicate" : {
                                        "class" : "uk.gov.gchq.koryphe.impl.predicate.IsEqual",
                                        "value" : "p-0"
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        }
    ]
}

res = g.execute(query)

ips = sets.Set([v["vertex"] for v in res])

query = {
    "class": "uk.gov.gchq.gaffer.operation.OperationChain",
    "operations": [
        {
            "class": "uk.gov.gchq.gaffer.operation.impl.get.GetAllElements",
            "view": {
                "entities": {
                    "ip": {
                    }
                }
            }
            
        },
        {
            "class" : "uk.gov.gchq.gaffer.operation.impl.GetWalks",
            "operations" : [
                {
                    "class" : "uk.gov.gchq.gaffer.operation.OperationChain",
                    "operations" : [
                        {
                            "class" : "uk.gov.gchq.gaffer.operation.impl.get.GetElements",
                            "includeIncomingOutGoing" : "OUTGOING",
                            "view": {
                                "edges": {
                                    "probed": {
                                    }
                                }
                            }
                        }
                    ]
                }
            ],
            "resultsLimit" : 1000000
        }
    ]
}

res = g.execute(query)

bad_ips = sets.Set([v["entities"][0].keys()[0] for v in res])

ips = ips - bad_ips

# Remove private addresses
private = sets.Set()
for v in ips:
    if ipaddress.ip_address(v).is_private:
        private.add(v)
ips = ips - private

# Convert set to list
ips = list(ips)

# Function allows management in chunks
def chunks(l, n):
    n = max(1, n)
    return (l[i:i+n] for i in xrange(0, len(l), n))

a = apility.Apility(uuid)

for chunk in chunks(ips, 50):

    print chunk
    
    try:
        res = a.get_ip_reputation(chunk)

    except Exception, e:
        print e
        time.sleep(5)
        continue

    rep = {}

    for v in res:
        ip = v["ip"]
        blacks = v["blacklists"]
        rep[ip] = blacks

    elts = []

    for v in rep:
        for w in rep[v]:

            elt = {
 	        "class": "uk.gov.gchq.gaffer.data.element.Edge",
 	        "properties": {
                    "time": {
                        "uk.gov.gchq.gaffer.time.RBMBackedTimestampSet": {
                            "timeBucket": "MINUTE",
                            "timestamps": [time.time()]
                        }
                    }
                },
 	        "group": "matches",
 	        "source": v,
 	        "destination": "apility." + w,
 	        "directed": True
 	    }
  
            elts.append(elt)

            elt = {
 	        "class": "uk.gov.gchq.gaffer.data.element.Entity",
                "properties": {
                    "type": "blocklist",
                    "source": "apility.io",
                    "publisher": "Apility",
                    "update": {
                        "uk.gov.gchq.gaffer.time.RBMBackedTimestampSet": {
                            "timeBucket": "MINUTE",
                            "timestamps": [time.time()]
                        }
                    },
                    "probability": 0.3
                },
                "group": "blocklist",
                "vertex": "apility." + w
            }

            elts.append(elt)
        
        elt = {
 	    "class": "uk.gov.gchq.gaffer.data.element.Edge",
            "source": v,
            "destination": "apility-ip",
            "properties": {
                "probeversion": "v0",
                "probetime": 1
            },
            "group": "probed"
        }

        elts.append(elt)

    if len(elts) > 0:
        elts = {
            "class": "uk.gov.gchq.gaffer.operation.impl.add.AddElements",
            "validate": True,
            "skipInvalidElements": False,
            "input": elts
        }

        url = "/rest/v2/graph/operations/execute"
        data = json.dumps(elts)
        response = g.post(url, data)
        print response
        print response.text

    time.sleep(1)

